ReqNo,Requirement Location,Feature,Sub Feature,Feature Description,Verification Goal,Pass/Fail Criteria,Test Type,Coverage Method,Link to Coverage
1,privspec,Misc,SupportedLevels,"""At any time a RISC-V hardware thread (hart) is running at some privilege level encoded as a mode in one or more CSRs [User Supervisor (Reserved) Machine]""",Run all supported levels (U-mode; M-mode); ensure no unsupported levels can be run (S-mode; reserved).,Assertion Check,ENV capability; not specific test,Functional Coverage,
2,,,ResetMode,"""M-mode [...] is the first mode entered at reset.""",Wait for reset to end - ensure that the core is in M-mode.,Assertion Check,ENV capability; not specific test,Assertion Coverage,
3,,,Refetch,Before a mode change; instructions can have been prefetched and exist in the pipeline but the fetching was done in a different mode than what is changed to. This should not allow for privilege escalation so the instructions must be refetched.,Make the core change privilege mode and let the first instruction that is attempted to be executed in the new mode follow on the address after the last instruction that was executed in the previous mode. But also 1) change the memory value of the new instruction then observe that two fetches occur and that the latest value is being executed and/or 2) let the second instruction have different PMP settings so a difference can be observed in the two fetches.,Assertion Check,Constrained-Random,Functional Coverage,
4,obi,,InstrProt,"""prot[2:1]: User/Application (2’b00); Supervisor (2’b01); Reserved (2’b10); Machine (2’b11). This matches the privilege levels from [RISC-V-PRIV].""",Track prot[2:1] on instruction fetches on obi then observe retirements on rvfi and ensure the effective privilege mode of the instruction's execution matches what it was fetched as on obi.,Assertion Check,Constrained-Random,Functional Coverage,
5,,,DataProt,,Track prot[2:1] on data loads/stores observe retirements on rvfi and ensure the effective privilege mode of the retirement matches what was used on obi.,Assertion Check,Constrained-Random,Functional Coverage,
6,privspec,CSRs,IllegalAccess,The next two bits (csr[9:8]) encode the lowest privilege level that can access the CSR. Attempts to access a CSR without appropriate privilege level […] also raise illegal instruction exceptions.,Try all kinds of accesses (R W RW S C …) to all M-level CSRs while in U-level; ensure illegal instruction exception happens. (Hint: Assert RVFI vs csr[9:8]) (Note: Might need to excuse mcounteren),Assertion Check,Constrained-Random,Functional Coverage,
7,,,MisaU,"""The “U” and “S” bits will be set if there is support for user and supervisor modes respectively.""","Read misa and see that ""U"" is always on.",Assertion Check,ENV capability; not specific test,Functional Coverage,
8,,,MisaN,"""N   Tentatively reserved for User-Level Interrupts extension""","Read misa and see that ""N"" is always off.",Assertion Check,ENV capability; not specific test,Functional Coverage,
9,,,UserExtensions,If both XS and FS are hardwired to zero; then SD is also always zero. In systems without additional user extensions requiring new state; the XS field is hardwired to zero. If neither the F extension nor S-mode is implemented; then FS is hardwired to zero. None of those 3 are implemented; so they should all be zero.,Check that mstatus {XS; FS; SD} are all 0.,Assertion Check,ENV capability; not specific test,Functional Coverage,
10,,,MscratchReliable,"""the OS can rely on holding a value in the mscratch register while the user context is running.""",Check that mscratch never changes in U-mode.,Assertion Check,Constrained-Random,Functional Coverage,
11,,,MppValues,"""xPP fields are WARL fields that can hold only privilege mode x and any implemented privilege mode lower than x""","Check that MPP can hold ""M"" and ""U"" and that it can hold nothing else.",Assertion Check,Constrained-Random,Functional Coverage,
12,,,MppProbe,"""M-mode software can determine whether a privilege mode is implemented by writing that  mode to MPP then reading it back.""",Write {00 01 10 11} to MPP and read each one back  ensuring only M-mode and U-mode is read.,Assertion Check,Constrained-Random,Functional Coverage,
13,,,SppValues,"""If privilege mode x is not implemented then xPP must be hardwired to 0.""",Check that SPP is always 0.,Assertion Check,Constrained-Random,Functional Coverage,
14,,,MedelegMideleg,"""In systems without S-mode; the medeleg and mideleg registers should not exist.""","Attempt access to these CSRs. (Could be ""upgraded"" to a self-checking test or random.)",Assertion Check,Directed Non-Self-Checking,Testcase,
15,,,Mcounteren,"""In systems with U-mode the mcounteren must be implemented""","Attempt access to this CSR. (See Counters section below too.) (Could be ""upgraded"" to a self-checking test or random.)",Assertion Check,Directed Non-Self-Checking,Testcase,
16,n-ext,,Next,N-extension CSRs used to be supported earlier in the legacy of the core's source code.,Ensure that the old N-ext CSRs cannot be accessed (ustatus; uie; utvec; uscratch; uepc; ucause; utval; uip).,Assertion Check,Directed Non-Self-Checking,Testcase,
17,manual,,Jvt,The vector table jump CSR is accessible and effective in U-mode.,This is a security hole? Get the specs sorted out.,Other,Other,N/A,
18,privspec,Traps,SoftwareInterrupts,(It is assumed that since U-mode software interrupts are not supported; that nothing related to this (e.g. priority and enable status) needs testing.),,N/A,N/A,N/A,
19,,,TrapMpp,"""When a trap is taken from privilege mode y into privilege mode x; […] xPP is set to y.""",Be in U-mode; observe an exception and an interrupt being handled in M-mode; ensure that MPP is set to U-mode.,Assertion Check,Constrained-Random,Assertion Coverage,
20,,,HigherEnabled,"""Interrupts for higher-privilege modes; y>x ;are always globally enabled regardless of the setting of the global yIE bit for the higher-privilege mode.""",Be in U-mode; run with MIE=0 and MIE=1; have an interrupt trigger (w/ per-interrupt enabled); ensure that the interrupt is always taken.,Assertion Check,Constrained-Random,Assertion Coverage,
21,,,HigherDisable,"""Higher-privilege-level code can use separate per-interrupt enable bits to disable selected higher-privilege-mode interrupts before ceding control to a lower-privilege mode.""",Be in U-mode; have an interrupt trigger but its per-interrupt enable (mie) is off; ensure that the interrupt is not taken.,Assertion Check,Constrained-Random,Assertion Coverage,
22,,,HigherNone,"""A higher-privilege mode y could disable all of its interrupts before ceding control to a lower-privilege mode""",(Can be combined w/ above item to extend it.),Other,Constrained-Random,Assertion Coverage,
23,,,LowerLevel,"""Interrupts for lower-privilege modes; w<x; are always globally disabled regardless of the setting of any global wIE bit for the lower-privilege mode.""",(Does not apply to U-mode.),N/A,N/A,N/A,
24,,,ToMmode,"""An interrupt i will trap to M-mode (causing the privilege mode to change to M-mode) [...]""",Ensure that whenever an interrupt is taken; it is handled in M-mode.,Assertion Check,Constrained-Random,Assertion Coverage,
25,,,MretMpp,"""When executing an xRET instruction; supposing xPP holds the value y […] the privilege mode is changed to y""",Be in M-mode; execute mret with MPP as U-mode and as M-mode; ensure correct priv mode being executed in.,Assertion Check,Constrained-Random,Assertion Coverage,
26,,,MretLeastPrivileged,"""When executing an xRET instruction [...] xPP is set to the least-privileged supported mode (U if U-mode is implemented; else M)""",Be in M-mode; execute mret; ensure that MPP is set to U-mode.,Assertion Check,Constrained-Random,Assertion Coverage,
27,,,MretMprv,"""When executing an xRET instruction [...] If xPP≠M; xRET also sets MPRV=0.""",Be in M-mode; have xPP=U; execute mret; ensure that MPRV is set to 0.,Assertion Check,Constrained-Random,Assertion Coverage,
28,,,Mepc,"""xRET sets the pc to the value stored in the xepc register.""",(Assumed to be covered by the exceptions vplan. Should apply regardless of privilege mode.),N/A,N/A,N/A,
29,,,TrapsMmode,"""By default; all traps at any privilege level are handled in machine mode;""",Observe traps (interrupts and exceptions) getting triggered while in M-mode and U-mode; ensure the handler always starts in M-mode.,Assertion Check,Constrained-Random,Functional Coverage,
30,privspec,Instructions,WfiExecute,"""When TW=0; the WFI instruction may execute in lower privilege modes when not prevented for some other reason.""",Be in U-mode; have mstatus.TW=0; execute a WFI; ensure operation works as normal.,Assertion Check,Constrained-Random,Assertion Coverage,
31,,,WfiIllegal,"""When TW=1; then if WFI is executed in any less-privileged mode;and it does not complete within an implementation-specific; bounded time limit;the  WFI instruction causes an illegal instruction exception.""",Be in U-mode; have mstatus.TW=1; execute a WFI; ensure illegal instruction exception occurs.,Assertion Check,Constrained-Random,Assertion Coverage,
32,,,Ecall,The ECALL [...]. When executed in U-mode [...] it generates an environment-call-from-U-mode exception [...]; and performs no other operation. The mcause register [...]. When a trap is taken into M-mode; mcause is written with a code indicating the event that caused the trap.,Be in U-mode; execute ECALL; ensure that an exception is taken and mcause is set correctly.,Assertion Check,Constrained-Random,Assertion Coverage,
33,,,Ebreak,(See ebreak under the debug feature section.),,Other,Other,N/A,
34,,,Mret,"""An xRET instruction can be executed in privilege mode x or higher""",Be in U-mode; execute MRET; ensure that it does not execute like it does in M-mode.,Assertion Check,Constrained-Random,Assertion Coverage,
35,,,CustomInstr,The subspace of the SYSTEM major opcode shown in Figure 3.30 is designated for custom use. Unprivileged or User-Level. (40s has no such thing.),"Execute custom SYSTEM ""Unprivileged or User-Level"" instructions; ensure they are illegal instructions.",Assertion Check,Constrained-Random,Assertion Coverage,
36,40p,,Uret,The uret instruction existed earlier in the core's history; but no longer exists.,Executing uret gives an illegal instruction exception.,Assertion Check,Constrained-Random,Assertion Coverage,
37,privspec,EffectiveMode,ModifyOff,"""When MPRV=0; loads and stores behave as normal; using the translation and protection mechanisms of the current privilege mode.""",Have PMA/PMP configured differently for U-mode and M-mode; have mstatus.MPRV=0 and mstatus.MPP={U/M}; attempt loads and stores in U-mode and M-mode; and ensure that the effect corresponds to the current mode.,Assertion Check,Constrained-Random,Assertion Coverage,
38,,,ModifyOn,"""When MPRV=1; load and store memory addresses are translated and protected; and endianness is applied; as though the current privilege mode were set to MPP""",Have PMA/PMP configured differently for U-mode and M-mode; have mstatus.MPRV=1 and mstatus.MPP={U/M}; attempt loads and stores in U-mode and M-mode; and ensure that the effect corresponds to the set mode (cross U/U; U/M; M/U; M/M).,Assertion Check,Constrained-Random,Assertion Coverage,
39,,,ModifyIside,"""Instruction address-translation and protection are unaffected by the setting of MPRV.""",Have PMA/PMP configured differently for U-mode and M-mode; have mstatus.MPRV=1 and mstatus.MPP={U/M}; attempt execution from corresponding regions; and ensure that the effect corresponds to the current mode.,Assertion Check,Constrained-Random,Assertion Coverage,
40,privspec,Counters,McounterenClear,"""When the CY; TM; IR; or HPMn bit in the mcounteren register is clear; attempts  to read the cycle; time; instret; or hpmcountern register while executing in S-mode or U-mode will cause an illegal instruction exception.""",Attempt to read all of those from U-mode while the corresponding bit is 0; ensure illegal instruction exception happens.,Assertion Check,Constrained-Random,Assertion Coverage,
41,,,McounterenSet,"""When one of these bits is set; access to the corresponding register is permitted in the next implemented privilege mode (S-mode if implemented; otherwise U-mode).""",Attempt to read all of those from U-mode while the corresponding bit is 1; ensure illegal instruction exception does not happen (for IR and CY; the rest should fail).,Assertion Check,Constrained-Random,Functional Coverage,
42,debug,Debug,TriggersAccess,"""The trigger registers; except scontext and hcontext; are only accessible in machine and Debug Mode to prevent untrusted user code from causing entry into Debug Mode without the OS’s permission.""",Be in U-mode; attempt access to all trigger registers; ensure access is denied (no read data retrieved; no write data written; and exception occurs).,Assertion Check,Directed Non-Self-Checking,Functional Coverage,
43,,,EbreakuOff,"""ebreak instructions in U-mode behave as described in the Privileged Spec.""","Have dcsr.ebreaku=0; be in U-mode; execute ebreak; ensure ""normal"" ebreak behavior and no debug entry.",Assertion Check,Constrained-Random,Assertion Coverage,
44,,,EbreakuOn,"""ebreak instructions in U-mode enter Debug Mode.""","Have dcsr.ebreaku=1; be in U-mode; execute ebreak; ensure debug entry happens instead of ""normal"" ebreak behavior.",Assertion Check,Constrained-Random,Assertion Coverage,
45,,,Mcontrol6Umode0,"""When set; enable this trigger in U-mode.""",Have a trigger configured so it can be activated; have mcontrol6.u=0; be in U-mode; activate the trigger condition and ensure that the trigger is not acted upon.,Assertion Check,Constrained-Random,Assertion Coverage,
46,,,Mcontrol6Umode1,"""When set; enable this trigger in U-mode.""",Have a trigger configured so it can be activated; have mcontrol6.u=1; be in U-mode; activate the trigger condition and ensure that the trigger is indeed acted upon.,Assertion Check,Constrained-Random,Assertion Coverage,
47,,,EtriggerUmode0,"""When set; enable this trigger for exceptions that are taken from U mode.""",Setup an exception trigger so it can be activated; have etrigger.u=0; be in U-mode; activate the trigger condition and ensure that the trigger is not acted upon.,Assertion Check,Constrained-Random,Assertion Coverage,
48,,,EtriggerUmode1,"""When set; enable this trigger for exceptions that are taken from U mode.""",Setup an exception trigger so it can be activated; have etrigger.u=1; be in U-mode; activate the trigger condition and ensure that the trigger is indeed acted upon.,Assertion Check,Constrained-Random,Assertion Coverage,
49,,,ExecuteMmode,"""All operations are executed with machine mode privilege […]""",Ensure that all rvfi retirements in D-mode also shows M-mode. Additionally; check that loads/stores act as if M-mode and that CSRs are accessible as in M-mode.,Assertion Check,Constrained-Random,Functional Coverage,
50,,,ExecuteMprven,"""[...] except that MPRV in mstatus may be ignored according to mprven.""",dcsr.mprven shall be hardwired to 0.,Assertion Check,ENV capability; not specific test,Functional Coverage,
51,,,Relaxedpriv,"""Full permission checks; or a relaxed set of permission checks; will apply according to relaxedpriv.""",(This relates to debug module registers and pertains to verification of integration in a subsystem.),N/A,N/A,N/A,
52,,,UnspecifiedBehav,"""Almost all instructions that change the privilege mode have unspecified behavior. This includes ecall; mret; sret; and uret.""",(This is unspecified so there is nothing to compare against.),N/A,N/A,N/A,
53,,,ResumePriv,"""When a hart resumes [...] The current privilege mode and virtualization mode are changed to that specified by prv and v.""",Transition out of D-mode; ensure that executions starts in the same privilege mode as was indicated in dcsr.prv.,Assertion Check,Constrained-Random,Assertion Coverage,
54,,,ResumeMprv,"""When a hart resumes: [...] If the new privilege mode is less privileged than M-mode; MPRV in mstatus is cleared.""",Transition out of D-mode (dret) into U-mode; while mstatus.mprv=1; ensure that when execution continues outside D-mode that mstatus.mprv=0.,Assertion Check,Constrained-Random,Assertion Coverage,
55,,,PrvEntry,"""prv Contains the privilege mode the hart was operating in when Debug Mode was entered.""",Transition into D-mode from M-mode and U-mode; ensure dcsr.prv contains the privilege mode that was running before D-mode.,Assertion Check,Constrained-Random,Functional Coverage,
56,,,PrvExit,"""prv [...] A debugger can change this value to change the hart’s privilege mode when exiting Debug Mode.""",Using dcsr.prv=M and dcsr.prv=U; exit debug bug; ensure execution continues in the specified privilege level.,Assertion Check,Constrained-Random,Functional Coverage,
57,,,PrvSupported,"""Not all privilege modes are supported on all harts. If the encoding written is not supported or the debugger is not allowed to change to it; the hart may change to any supported privilege mode.""",Write unsupported modes to dcsr.prv; ensure the value read back is supported.,Assertion Check,Directed Non-Self-Checking,Functional Coverage,
58,,,NativeTriggers,"""Triggers can be used for native debugging when action =0. If supported by the hart and desired by the debugger; triggers will often be programmed to have m=0 so that when they fire they cause a breakpoint exception to trap to a more privileged mode.""",(Assumed to be covered by the debug/triggers vplan.),N/A,N/A,N/A,
59,,,DretPrv,"""When dret is executed; [...] normal execution resumes at the privilege set by prv.""",(Covered by items above.),Other,Other,Assertion Coverage,
60,,,Mprven0Simulate,"""If hardware ties mprven to 0 then the external debugger is expected to simulate all the effects of MPRV; including any extensions that affect memory accesses.For these reasons it is recommended to tie mprven to 1.""",(This is a requirement for the external debugger.),N/A,N/A,N/A,
61,,,Mprven0Ignore,"""mprven    0: MPRV in mstatus is ignored in Debug Mode.""",Set up mprv and mpp as if U-mode would be the effective level; be in D-mode and ensure that M-mode is still effectively the level executed in.,Assertion Check,Constrained-Random,Functional Coverage,
